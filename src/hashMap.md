## HashMap
### 底层结构
数组+链表
### 扩容
1. 有两个影响因素：
    - Capacity：HashMap当前长度。
    - LoadFactor：负载因子，默认值0.75f。
2. 扩容分为两步
    - 扩容：创建一个新的Entry空数组，长度是原数组的2倍。
    - ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。
### 为什么要ReHash
1. 长度扩大以后，Hash的规则也随之改变。
2. Hash的公式---> index = HashCode（Key） & （Length - 1）
### Java7和Java8的区别
1. 数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node。
2. 如果hash值相同的实例，在Java7的插入方式为头插，Java为尾插，因为头插会改变链表顺序，可能产生环形链表的问题，而尾插则不会改变顺序
### 环形链表
1. resize的赋值方式，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。
2. 这样就可能发生如下情况
#### B的下一个指针指向了A
![初始数组](https://nxj.oss-cn-hangzhou.aliyuncs.com/640.webp.jpg)
#### 一旦几个线程都调整完成，就可能出现环形链表
![处理完成后数组](https://nxj.oss-cn-hangzhou.aliyuncs.com/641.webp.jpg)
#### 如果这个时候去取值，就会出现——Infinite Loop。
### 为什么HashMap初始化大小是16
1. 因为使用1<<4这种位运算效率很高
2. index = HashCode（Key） & （Length- 1）
    - 因为在使用不是2的幂的数字的时候，Length-1的值是所有二进制位全为1（15的二进制为1111），这种情况下，index的结果等同于HashCode后几位的值。
    - 只要输入的HashCode本身分布均匀，Hash算法的结果就是均匀的。
    - 这是为了实现均匀分布，降低hash碰撞。
### 为什么负载因子是0.75f
1. 当负载因子是1.0的时候，数组全部填充了，才会发生扩容。这就带来了很大的问题，因为Hash冲突时避免不了的。当负载因子是1.0的时候，意味着会出现大量的Hash的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。
2. 负载因子是0.5的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，Hash冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。但是空间利用率低了。
3. 负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。
### Hash碰撞的解决方法
HasHmap使用的是链表法，所以是数组+链表的结构
### Hash冲突的解决方法
1. 开放定址法：一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
2. 链地址法：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来。
3. 再哈希法：使用不同的Hash函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。
4. 建立一个公共溢出区域：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表
### HashMap线程不安全
1. 在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。
2. 在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。
